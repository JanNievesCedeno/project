# Portfolio
#### Video Demo:  <https://www.youtube.com/watch?v=pGhn7y1IWLY>
#### Description:

For my final project, I decided to create a web portfolio that showcases my most significant projects to date. To build this website, I utilize a range of technologies covered in the CS50 course, including Flask, SQLite, Python, HTML, CSS, and Bootstrap, each playing a crucial role in the overall functionality and design of the site.

The initial step in my project was to install all the necessary technologies on my computer so I could work efficiently within the local Visual Studio Code editor. This setup process involved installing the Flask framework and creating the file’s structure. Once I had Flask installed, I moved on to creating the database that consists of three primary tables: users, projects, and contact. 
The users table is designed to create new users, it contains three columns: id, which is an integer and serves as the primary key; username, which is a text field for user identification; and password, which is also a text field that stores user passwords securely. The primary purpose of the users table is to control access to the dashboard routes, where the administrator can manage the database, including adding or modifying projects and viewing messages submitted through the contact form.

The projects table is where I store all relevant information about the projects I wish to showcase. It includes seven columns: id (an integer that acts as the primary key), userid (a foreign key that references the users table), and additional columns for project details such as name, description, languages, img, and video, all of which are text fields. Initially, I considered using BLOB types for the img and video columns to store multimedia files directly in the database. However, after careful consideration, I decided against this approach. Storing media as BLOBs would require complex conversion processes to save the files as binary data and then convert them back to their original format for display on the portfolio. Instead, I opted to store the file paths or URLs in the database and handle the media files separately.

The contact table serves as a way for visitors to leave messages. It consists of five columns: id (an integer that acts as the primary key) and contact information columns for fname (first name), lname (last name), email, and message. All of these fields are text types, allowing users who are viewing my portfolio to submit their messages directly through the contact form.

With the database structure in place, I proceeded to work on the app.py file, which is the heart of my Flask application. In this file, I imported all the necessary libraries and established a connection to the database. Afterward, I created all the routes required for my portfolio, including two main routes for the public portfolio section and seven additional routes for the administrative dashboard.

The first route for the portfolio is the home route. When this route is accessed, the application queries the database for all available projects and returns them to the home.html template. This ensures that visitors can see an overview of my work right from the homepage. The second route is aboutme. When this route is accessed via the GET method, it returns the aboutme.html template, which provides background information about me as a developer. However, if the route is requested via POST, it collects user input from the contact form and saves it to the contact table in the database, enabling visitors to reach out to me easily.

Turning to the dashboard routes, the first route is login. When this route is requested, it first clears any existing session data to ensure a fresh start. If the request method is GET, it returns the dashboard/login.html template for user login. If the method is POST, the application processes the user input, checking the database for the user’s existence and verifying their password. If both conditions are met, the user ID is saved in the session, allowing the user to access the dashboard.

The dashboard route itself serves as a landing page for logged-in users. When this route is accessed via GET, it retrieves the user ID from the session and queries the database for the user’s associated projects. It also collects all records from the contact table, returning the dashboard/records.html template, which displays both the projects and any messages left by visitors. If the dashboard route is accessed via POST, it allows for updating project information. The application retrieves a project ID, finds the corresponding record in the database, and presents it in the dashboard/update.html template for editing.

Another important route is dashboard/adduser, which facilitates the creation of new user accounts. When requested via POST, it gathers the username and password, checks if the user already exists, hashes the password for security, and saves it to the database. If accessed via GET, it returns the dashboard/adduser.html template for creating a new user. The dashboard/addproject route allows me to add new projects to the database. When requested via GET, it returns the dashboard/addproject.html template, while a POST request collects user inputs and saves the project details, including any media files, to the appropriate directories.

The dashboard/update route is designated for updating existing project information as necessary. Lastly, there are the dashboard/delete and dashboard/logout routes, which serve to delete projects and log users out of the dashboard, respectively.

After successfully implementing the backend functionality, I shifted my focus to the front-end design of the website. I utilized Bootstrap to ensure that images, videos, and tables are responsive across different devices, providing an optimal user experience and, I employed CSS alongside Bootstrap to style the website.

